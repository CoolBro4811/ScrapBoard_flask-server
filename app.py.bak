from flask import Flask, request, jsonify
from PIL import Image
import torch
from torchvision import transforms
from torchvision.models import resnet50
import os

# Initialize Flask app
app = Flask(__name__)

# Define your PyTorch model architecture
class MyModel(torch.nn.Module):
    def __init__(self):
        super(MyModel, self).__init__()
        # Example architecture; replace with your actual model definition
        self.conv1 = torch.nn.Conv2d(3, 16, kernel_size=3, stride=1, padding=1)
        self.relu = torch.nn.ReLU()
        self.pool = torch.nn.MaxPool2d(kernel_size=2, stride=2)
        self.fc = torch.nn.Linear(16 * 112 * 112, 10)

    def forward(self, x):
        x = self.conv1(x)
        x = self.relu(x)
        x = self.pool(x)
        x = x.view(x.size(0), -1)  # Flatten
        x = self.fc(x)
        return x

# Load the model
model_path = 'model/model.pth'  # Update with your model's path
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = resnet50(pretrained=False)  # Ensure this matches the saved model architecture
model.load_state_dict(torch.load(model_path, map_location=device))
model = model.to(device)
model.eval()

# Configure upload folder
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Define the preprocessing pipeline
preprocess = transforms.Compose([
    transforms.Resize((224, 224)),  # Resize image to match model input size
    transforms.ToTensor(),          # Convert image to tensor
    transforms.Normalize(           # Normalize using ImageNet means/stds (or your own)
        mean=[0.485, 0.456, 0.406], 
        std=[0.229, 0.224, 0.225]
    )
])

# Route for image classification
@app.route('/classify', methods=['POST'])
def classify_image():
    # Check if the request contains a file
    if 'image' not in request.files:
        return jsonify({'error': 'No image file found'}), 400

    image_file = request.files['image']
    if image_file.filename == '':
        return jsonify({'error': 'No file selected'}), 400

    # Save the file (optional)
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], image_file.filename)
    image_file.save(filepath)

    # Preprocess the image
    try:
        image = Image.open(filepath).convert('RGB')  # Ensure RGB mode
        input_tensor = preprocess(image).unsqueeze(0)  # Add batch dimension
        input_tensor = input_tensor.to(device)
    except Exception as e:
        return jsonify({'error': f'Error processing image: {str(e)}'}), 400

    # Predict using the model
    try:
        with torch.no_grad():
            outputs = model(input_tensor)
            probabilities = torch.nn.functional.softmax(outputs[0], dim=0)
            predicted_class = torch.argmax(probabilities).item()
            confidence = probabilities[predicted_class].item()
    except Exception as e:
        return jsonify({'error': f'Model prediction failed: {str(e)}'}), 500

    return jsonify({
        'predicted_class': int(predicted_class),
        'confidence': float(confidence)
    })

# Run the server
if __name__ == '__main__':
    app.run(debug=True)

